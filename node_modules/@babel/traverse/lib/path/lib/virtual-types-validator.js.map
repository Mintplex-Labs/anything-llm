{"version":3,"names":["_t","require","isBinding","isBlockScoped","nodeIsBlockScoped","isExportDeclaration","isExpression","nodeIsExpression","isFlow","nodeIsFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isRestElement","nodeIsRestElement","isReferenced","nodeIsReferenced","isScope","nodeIsScope","isStatement","nodeIsStatement","isVar","nodeIsVar","isVariableDeclaration","react","isForOfStatement","isCompatTag","isReferencedIdentifier","opts","node","parent","name","parentPath","isReferencedMemberExpression","isBindingIdentifier","grandparent","left","init","isUser","loc","isGenerated","isPure","constantsOnly","scope","importKind","exportKind","isRestProperty","_this$parentPath","isObjectPattern","isSpreadProperty","_this$parentPath2","isObjectExpression","isForAwaitStatement","await","exports","isExistentialTypeParam","Error","isNumericLiteralTypeAnnotation"],"sources":["../../../src/path/lib/virtual-types-validator.ts"],"sourcesContent":["import type NodePath from \"../index.ts\";\nimport {\n  isBinding,\n  isBlockScoped as nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression as nodeIsExpression,\n  isFlow as nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement as nodeIsRestElement,\n  isReferenced as nodeIsReferenced,\n  isScope as nodeIsScope,\n  isStatement as nodeIsStatement,\n  isVar as nodeIsVar,\n  isVariableDeclaration,\n  react,\n  isForOfStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst { isCompatTag } = react;\nimport type { VirtualTypeAliases } from \"./virtual-types.ts\";\n\ntype Opts<Obj> = Partial<{\n  [Prop in keyof Obj]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport interface VirtualTypeNodePathValidators {\n  isBindingIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"BindingIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"BindingIdentifier\"]>;\n  isBlockScoped(opts?: Opts<VirtualTypeAliases[\"BlockScoped\"]>): boolean;\n  /**\n   * @deprecated\n   */\n  isExistentialTypeParam(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ExistentialTypeParam\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ExistentialTypeParam\"]>;\n  isExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Expression\"]>,\n  ): this is NodePath<t.Expression>;\n  isFlow(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Flow\"]>,\n  ): this is NodePath<t.Flow>;\n  isForAwaitStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ForAwaitStatement\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ForAwaitStatement\"]>;\n  isGenerated(opts?: VirtualTypeAliases[\"Generated\"]): boolean;\n  /**\n   * @deprecated\n   */\n  isNumericLiteralTypeAnnotation(\n    opts?: VirtualTypeAliases[\"NumericLiteralTypeAnnotation\"],\n  ): void;\n  isPure(opts?: VirtualTypeAliases[\"Pure\"]): boolean;\n  isReferenced(opts?: VirtualTypeAliases[\"Referenced\"]): boolean;\n  isReferencedIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedIdentifier\"]>;\n  isReferencedMemberExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedMemberExpression\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedMemberExpression\"]>;\n  isRestProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"RestProperty\"]>,\n  ): this is NodePath<t.RestProperty>;\n  isScope(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Scope\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Scope\"]>;\n  isSpreadProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"SpreadProperty\"]>,\n  ): this is NodePath<t.SpreadProperty>;\n  isStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Statement\"]>,\n  ): this is NodePath<t.Statement>;\n  isUser(opts?: VirtualTypeAliases[\"User\"]): boolean;\n  isVar(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Var\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Var\"]>;\n}\n\nexport function isReferencedIdentifier(this: NodePath, opts?: any): boolean {\n  const { node, parent } = this;\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      // not a JSXIdentifier or an Identifier\n      return false;\n    }\n  }\n\n  // check if node is referenced\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nexport function isReferencedMemberExpression(this: NodePath): boolean {\n  const { node, parent } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nexport function isBindingIdentifier(this: NodePath): boolean {\n  const { node, parent } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nexport function isStatement(this: NodePath): boolean {\n  const { node, parent } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, { left: node })) return false;\n      if (isForStatement(parent, { init: node })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nexport function isScope(this: NodePath): boolean {\n  return nodeIsScope(this.node, this.parent);\n}\n\nexport function isReferenced(this: NodePath): boolean {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nexport function isBlockScoped(this: NodePath): boolean {\n  return nodeIsBlockScoped(this.node);\n}\n\nexport function isVar(this: NodePath): boolean {\n  return nodeIsVar(this.node);\n}\n\nexport function isUser(this: NodePath): boolean {\n  return this.node && !!this.node.loc;\n}\n\nexport function isGenerated(this: NodePath): boolean {\n  return !this.isUser();\n}\n\nexport function isPure(this: NodePath, constantsOnly?: boolean): boolean {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nexport function isFlow(this: NodePath): boolean {\n  const { node } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\n// TODO: 7.0 Backwards Compat\nexport function isRestProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectPattern();\n}\n\nexport function isSpreadProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectExpression();\n}\n\nexport function isForAwaitStatement(this: NodePath): boolean {\n  return isForOfStatement(this.node, { await: true });\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.isExistentialTypeParam = function isExistentialTypeParam(\n    this: NodePath,\n  ): void {\n    throw new Error(\n      \"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\",\n    );\n  };\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.isNumericLiteralTypeAnnotation =\n    function isNumericLiteralTypeAnnotation(this: NodePath): void {\n      throw new Error(\n        \"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\",\n      );\n    };\n}\n"],"mappings":"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","ignoreList":[]}